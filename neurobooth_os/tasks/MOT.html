<!DOCTYPE html>

<html lang="en">

<!--[if lt IE 10]>

<script type="text/javascript">

    alert("The content of this web page may not work as intended in " +
            "the current browser. " +
            "Internet Explorer 10 or newer is required for full functionality.");
</script>

<![endif]-->


<head>

<!-- Metadata ************************************************************** -->

    <meta charset="UTF-8">
    <meta name="description" content="Multiple Object Tracking">
    <meta name="copyright" content="2014 The Many Brains Project, Inc.">
    <meta name="author" content="Paolo Martini">
    <meta name="keywords" content="cognitive test, brain test">

    <!-- Configs for mobiles -->

    <!-- Set the viewport. -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Allow web app to be run in full-screen mode. -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Make the app title different than the page title. -->
    <meta name="apple-mobile-web-app-title" content="MOT test">

    <!-- Icons. -->

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="shortcut icon" href="/favicon.ico">

<!-- End of metadata ******************************************************* -->

<!-- Â© 2016 The Many Brains Project, Inc.


     July      2014  Ver. 1.0 (First release)
     August    2014  Ver. 1.1 (Changed dot speeds)
     September 2014  Ver. 1.2 (Fixes for IE8)
     January   2015  Ver. 1.3 (Fixed bug: in previous versions, multiple clicks
                               on the same target counted as correct)
     March     2018  Ver. 1.4 (rewrite with mods for mobiles, switched to snap-svg)

     URL parameters:

        debug=true        : output trial by trial information to console
        showresults=true  : opens a new window to copy results, with button to save CSV file on local disk
        autosave=true     : save data to file automatically
        filename=test.csv : filename to save data to
        demo=true         : runs in demo mode (only one trial per block)
        dots=#dots        : number of total dots for all trials (minimum 6)
        seed=#            : random number generator seed
        help              : show usage

     Usage: MOTTest.html?debug=true
            MOTTest.html?showresults=true
            MOTTest.html?debug=true&showresults=true
            MOTTest.html?dots=10
            MOTTest.html?seed=31
            MOTTest.html?help
-->

<!-- Title ***************************************************************** -->

    <title>Multiple Object Tracking</title>

<!-- End of Title ********************************************************** -->

<!-- css Style declarations ************************************************ -->

    <style type="text/css">

        *
        {
            border-radius: 0;
            box-sizing: border-box;
        }

        *::after, *::before
        {
            box-sizing: border-box;
        }

        body
        {
            width: 100vw;
            height: 100vh;
            margin: auto;
            background: #ffffff;
            color: #000000;
            font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
            font-size: 13pt;
            text-align: center;
        }

        .inst
        {
            width: 540px;
            height: 500px;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -270px;
            margin-top: -250px;
            display: block;
            text-align: center;
            background: #ffffff;
            color: #000000;
            font-size: 20pt;
        }

        .stim
        {
            width: 500px;
            height: 500px;
            background-color: white;
            position:absolute;
            left:50%;
            top:50%;
            margin-top: -270px;
            margin-left: -250px;
        }

        #feedback
        {
            width: 500px;
            height: 40px;
            background-color: white;
            position:absolute;
            left:50%;
            top:50%;
            margin-top: 230px;
            margin-left: -250px;
            font-size: 25pt;
        }

        #textLeft
        {
            float: left;
            width: 30%;
            text-align: left;
        }

        #textMiddle
        {
            width: 60%;
            text-align: center;
            color: blue;
        }

        #textRight
        {
            float: right;
            width: 30%;
            text-align: right;
        }

        .button
        {
            font-size: 1.2em;
            line-height: 1.5em;
            border: 2px solid #f1c40f;
            border-radius: 1em;
            text-align: center;
            background: transparent;
            color: #000000;
            box-shadow: 0 5px 15px 5px grey
        }

        .button:active
        {
            box-shadow: 0 5px 15px 1px lightgrey
        }

        .button:focus
        {
            outline: none
        }


    </style>

<!-- end of css Style declarations ***************************************** -->

<!-- required js libraries ************************************************* -->

    <script type="text/javascript" src="snap.0.5.1.min.js"></script>
    <script type="text/javascript" src="TestMyBrain.12.17.min.js"></script>

<!-- end of required js libraries ****************************************** -->

<!-- js script ************************************************************* -->

    <script type="text/javascript">

        var circle = [];            // Array of SVG circles objects
        var happy =[];              // array of happy targets
        var sad = [];               // array of sad targets
        var mycircle = {x:[],       // circle x
                        y:[],       // circle y
                        d:[],       // circle motion direction in deg
                        r:15,       // circle radius
                        z:4,        // circle repulsion radius
                        noise: 15,  // motion direction noise in deg
                        speed: 2};  // circle speed in pixels/frame
        var numCircles = 10;        // total # of circles
        var numTargets = 4;         // # of targets to track
        var targets = [];           // array indicating whether targets are clicked
        var clicks = 0;             // # of clicks
        var targetClicks = 0;       // # of clicked targets
        var duration = 5000;        // desired duration of trial in ms
        var trueDuration;           // measured duration of trial in ms
        var frametime = 0;          // measured display frame duration in ms
        var paper;                  // stimulus graphics page
        var paperSize = 500;        // size of stimulus graphics page
        var timeoutRef;             // reference to the click timeout trap
        var clickTimeout = 15000;   // timeout for clicking on targets
        var frameSequence = [];     // object containing the sequence of frames and their properties
        var frame;                  // single frame object
        var timestamp;              // used for timing
        var rt;                     // reaction time
        var practiceErr = 0;        // practice errors counter
        var trialCount = 0;         // trial counter
        var results = [];           // to store trials details and responses
        var outcomes = {};          // object containing outcome variables
        var score=0;                // cumulative correct hits
        var total=0;                // max possible score
        var debug;                  // URL parameter: output to console
        var showresults;            // URL parameter: if we want to show results in a popup window and save to file
        var autosave;               // URL parameter: if they want to save data in a file automatically
        var filename;               // URL parameter: filename for data
        var demo = false;           // URL parameter: if we want a quick demo run (only 1 trial per block)
        var dots = 10;              // URL parameter: if we want # of dots
        var seed = 1;               // URL parameter: if we want a particular random number generator seed
        var usage= "";              // URL parameter: show usage

        // output a message and execute an action
        function showAlert(alertMessage,alertButtonText,action,timeout)
        {
            // set the message to display
            getID('alertText').innerHTML = alertMessage;

            // if args contain button text,
            // show the button and set the required action for it,
            // otherwise hide the button
            if(alertButtonText && !timeout)
            {
                getID('alertButton').style.width='15em';
                getID('alertButton').style.margin='0 auto';
                getID('alertButton').style.display='block';
                getID('alertButton').innerHTML = alertButtonText;
                getID('alertButton').onclick = action;
                showCursor("document.body");
            }
            else getID('alertButton').style.display='none';

            // if args contain a timeout,
            // trigger the action automatically when timeout expires
            if(timeout) setTimeout(action,timeout);

            showFrame('alertBox');
        }

        // log results to console
        function logResults()
        {
            if(!results[0]) return;

            var log = '', propertyName, len = results.length;
            if(len === 1)
            {
                for (propertyName in results[0])
                {
                    if(results[0].hasOwnProperty(propertyName))
                        log += propertyName+' ';
                }
                console.log(log);
                log= '';
            }
            for (propertyName in results[len-1])
            {
                if (results[len-1].hasOwnProperty(propertyName))
                    log += (results[len-1][propertyName] + ' ');
            }
            console.log(log);
        }

        // initialize the dots
        function setup()
        {
            var tooClose;

            // initialize start positions and motion directions randomly
            for(var i = 0; i < numCircles; i++)
            {
                mycircle.x[i] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                mycircle.r;
                mycircle.y[i] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                mycircle.r;
                mycircle.d[i] = Math.random() * 2 * Math.PI;
            }

            // enforce proximity limits
            for(i = 1; i < numCircles; i++)
            {
                // this loop repositions each circle until it's outside
                // the repulsion area of all other circles
                tooClose=true;
                while(tooClose)
                {
                    mycircle.x[i] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                    mycircle.r;
                    mycircle.y[i] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                    mycircle.r;

                    // repulsion distance defaults to 5 times the circle's radius
                    tooClose=false;
                    for (var j = 0; j < i; j++)
                    {
                        if(euclidDistance(mycircle.x[i],mycircle.y[i],
                                          mycircle.x[j],mycircle.y[j]) < 5 * mycircle.r)
                        {
                            tooClose=true;
                            break;
                        }
                    }
                }
            }

            // when done, update the circles on the DOM
            for(i = 0; i < numCircles; i++)
            {
                circle[i] = paper.circle(mycircle.x[i], // cx
                                         mycircle.y[i], // cy
                                         mycircle.r);   // r
                circle[i].attr({fill: "black"});        // colour
                circle[i].data("index", i);             // index tag
            }

            // draw a box for the circles
            paper.rect(0,0,paperSize,paperSize).attr({"stroke": "black",
                                                      "stroke-width": "2px",
                                                      "fill": "none"});

            // create numtargets happy green dots and hide them
            for(i = 0; i < numTargets; i++)
            {
                happy[i] = paper.image("happy-green-border.jpg",
                    0, 0, 2 * mycircle.r, 2 * mycircle.r);
                happy[i].node.style.display = "none";
            }
            // create numcircles sad red dots and hide them
            for(i = 0; i < numCircles; i++)
            {
                sad[i] = paper.image("sad-red-border.jpg",
                                       0,0,2*mycircle.r,2*mycircle.r);
                sad[i].node.style.display = "none";
            }

        }

        // update the position of the circles for the next frame
        function moveCircles()
        {
            // - add noise to the velocity vector
            // - bounce circles off elastic boundaries
            // - avoid collisions b/w circles
            // all computations are done outside the DOM

            var oldX, oldY;
            var newX, newY, newD;
            var velocityX, velocityY;
            var tooClose = true;
            var timeout = 0, sign = 1;
            var noise = Snap.rad(mycircle.noise);
            var repulsion = mycircle.z * mycircle.r;

            for(var i = 0; i < numCircles; i++)
            {
                // save the current dot's coordinates
                oldX = mycircle.x[i];
                oldY = mycircle.y[i];

                // update direction vector with noise
                newD = mycircle.d[i] + Math.random() * 2.0 * noise - noise;

                // compute x and y shift
                velocityX = Math.cos(newD) * mycircle.speed;
                velocityY = Math.sin(newD) * mycircle.speed;

                // compute new x and y coordinates
                newX = oldX + velocityX;
                newY = oldY + velocityY;

                // compute a random sign
                sign=randSign();

                // avoid collisions
                for(var j = 0; j < numCircles; j++)
                {
                    // skip self
                    if(j === i) continue;

                    // we look ahead one step:
                    // if the next move collides, the direction is updated
                    // until there's no collision or timeout
                    tooClose = true;
                    timeout = 0;
                    while(tooClose && timeout < 100)
                    {
                        timeout++;
                        if(euclidDistance(newX,newY,
                                          mycircle.x[j],mycircle.y[j]) <= repulsion)
                        {
                            // update vector direction
                            newD += sign * 0.05 * Math.PI;
                            // recompute  x shift and x coordinate
                            velocityX = Math.cos(newD) * mycircle.speed;
                            newX = oldX + velocityX;
                            // recompute  y shift and y coordinate
                            velocityY = Math.sin(newD) * mycircle.speed;
                            newY = oldY + velocityY;
                        }
                        else tooClose=false;
                    }
                }

                // enforce elastic boundaries
                if(newX >= paperSize - mycircle.r || newX <= mycircle.r)
                {
                    // bounce off left or right boundaries
                    velocityX *= -1; //invert x component of velocity vector
                    newX = oldX + velocityX; // recompute new x coordinate
                }
                if(newY >= paperSize - mycircle.r || newY <= mycircle.r)
                {
                    // bounce off top or bottom boundaries
                    velocityY *= -1; //invert y component of velocity vector
                    newY = oldY + velocityY; // recompute new y coordinate
                }

                // assign new coordinates to each circle
                mycircle.x[i] = newX;
                mycircle.y[i] = newY;

                // compute final vector direction
                // use atan2 (not atan)!
                mycircle.d[i] = Math.atan2(velocityY,velocityX);

                // now we update the DOM elements
                circle[i].node.setAttribute ("cx", newX);
                circle[i].node.setAttribute ("cy", newY);
                //circle[i].attr({cx: newX, cy: newY});
            }
        }

        function ShowTargets()
        {
            // move the happy green smileys to the coordinates
            // of the targets, make them visible and hide the dots
            for(var i = 0; i < numTargets; i++)
            {
                happy[i].attr({"x": circle[i].attr("cx")-mycircle.r,
                               "y": circle[i].attr("cy")-mycircle.r});
                happy[i].node.style.display = "block";
                circle[i].node.style.display = "none";
            }
        }

        function HideTargets()
        {
            // make the dots visible and hide the smileys
            for(var i = 0; i < numTargets; i++)
            {
                happy[i].node.style.display = "none";
                circle[i].node.style.display = "block";
            }
        }

        var clickHandler = function (e)
        {
            // this handler listens for clicks on the targets
            // reveals correct and incorrect clicks
            // stops listening after numTargets clicks
            // gives feedback and paces the trial presentation

            var i;

            // retrieve the identity of this dot
            var index = this.data("index");

            // increment the clicks counter
            clicks++;

            // mark correct as green
            if(index < numTargets)
            {
                happy[index].attr({"x": circle[index].attr("cx")-mycircle.r,
                                   "y": circle[index].attr("cy")-mycircle.r});
                happy[index].node.style.display = "block";
                circle[index].node.style.display = "none";
                //circle[index].attr({fill: "chartreuse"});

                // check they are not clicking on an already clicked target
                if(targets[index] === 0)
                {
                    targets[index] = 1;
                    targetClicks++;

                    if (frame.type === "test")
                    {
                        // update the score
                        score++;
                        getID("textRight").innerHTML = "Score "+score;
                    }
                }
            }
            // mark wrong as red
            else
            {
                sad[index].attr({"x": circle[index].attr("cx")-mycircle.r,
                                 "y": circle[index].attr("cy")-mycircle.r});
                sad[index].node.style.display = "block";
                circle[index].node.style.display = "none";
            }

            // check if we got enough clicks
            if(clicks === numTargets)
            {
                rt = timestamp;
                timestamp = now();
                rt = timestamp - rt;

                // clear the click timeout trap
                clearTimeout(timeoutRef);

                // disable the click handlers
                for(i = 0; i < numCircles; i++) circle[i].unclick();

                // push this trial in the results record
                results.push(
                {
                    type: frame.type, // one of practice or test
                    hits: targetClicks,
                    rt: rt.round(2),
                    numTargets: numTargets,
                    numdots: numCircles,
                    speed: mycircle.speed,
                    noise: mycircle.noise,
                    duration: trueDuration.round(2),
                    state: e.type,
                    seed: frame.message
                });

                // if we are debugging, log the results
                if(debug === 'true') logResults();

                if(frame.type === "test")
                {
                    // update total
                    total += numTargets;

                    // start a new trial
                    setTimeout(function () {nextTrial();}, 1500);
                }
                else if(frame.type === "practice")
                {
                    var msg = "<br><br><br><br>You got " + targetClicks +
                              " of " + numTargets +
                              " dots correct.<br><br><br>";

                    // deal with practice errors
                    if(targetClicks < numTargets)
                    {
                        // we allow repeating practice trials 2 times
                        if(practiceErr < 2)
                        {
                            // rewind the trials chain by one
                            frameSequence.unshift(frame);

                            msg = "<br><br>Let's try again.<br><br>"+
                                  "When the movement stops,<br>"+
                                  "click the " + numTargets +
                                  " dots that flashed.<br><br><br>";

                            practiceErr++;
                        }
                    }
                    else practiceErr = 0;

                    // give feedback
                    setTimeout(function ()
                    {
                        showAlert(msg,
                                  "Click here to continue",
                                  function ()
                                  {
                                      showFrame("null");
                                      nextTrial();
                                  });
                    }, 500);
                }
            }
        };

        function showMovingDots()
        {
            var motionTimer = 0, motionIterations = 0;

            // clear the canvas and feedback text
            if(paper) paper.clear();
            getID("textMiddle").innerHTML = "";

            // show the stimulus DIV and hide all others
            showFrame("canvasContainer","feedback");

            // set the random seed for each trial
            Math.seedrandom(frame.message);

            // initialize the dots
            setup();

            if(frame.type === "test")
            {
                // update and show the trial counter and score
                if(trialCount === 6 || demo === "true") trialCount = 0;
                trialCount++;
                getID("textLeft").innerHTML = trialCount + ' of 6';
                getID("textRight").innerHTML = 'Score ' + score;
            }

            // then set the motion scheduler
            function update()
            {
                // get a timestamp for the beginning of the motion
                if(!motionTimer) trueDuration = now();

                // increment the frame counter
                motionTimer++;

                // animate
                moveCircles();

                // exit the animation when we have reached the required duration
                if(motionTimer === motionIterations)
                {
                    // compute real duration
                    trueDuration = now() - trueDuration;

                    // show the cursor again
                    showCursor("canvasContainer");

                    if (frame.type === "practice" ||
                        frame.type === "test")
                    {
                        // start recording clicks
                        for (var j = 0; j < numCircles; j++)
                            circle[j].click(clickHandler);

                        // set a timeout trap
                        timeoutRef = setTimeout(function ()
                        {
                            // remove the click handlers
                            for(var k = 0; k < numCircles; k++)
                                circle[k].unclick(clickHandler);

                            results.push(
                            {
                                type: frame.type, // practice or test
                                hits: 0, // number of correct target clicks
                                rt: 0, // rt for this trial
                                numTargets: numTargets, // # of target dots
                                numdots: numCircles, // # of total dots
                                speed: mycircle.speed, // dot speed pixels/frame
                                noise: mycircle.noise, // +-deg added randomly to direction
                                duration: trueDuration.round(2), // total ms of animation
                                state: 'timeout', // click or timeout
                                seed: frame.message // random generator seed for this trial
                            });

                            // if we are debugging, log the results
                            if(debug === 'true') logResults();

                            if(frame.type === "test" && trialCount > 0)
                                trialCount--;
                            frameSequence.unshift(frame);

                            showAlert("<br><br>You took too long to respond!<br><br>" +
                                      "Remember:<br>once the movement stops,<br>" +
                                      "click the dots that flashed.<br><br><br>",
                                      "Click here to retry",
                                      function ()
                                      {
                                          showFrame("null");
                                          nextTrial();
                                      });

                        }, clickTimeout);

                        // initialize the clicks counter
                        clicks = targetClicks = 0;

                        // get a timestamp to calculate RT
                        timestamp = now();

                        if (frame.type === "practice")
                            getID("textMiddle").innerHTML = "Click the " +
                                                            numTargets +
                                                            " dots that flashed!";

                        else if (frame.type === "test")
                            getID("textMiddle").innerHTML = "Click " + numTargets +
                                                            " dots"
                    }
                    else setTimeout(function ()
                    {
                        nextTrial();
                    }, 1500);
                }
                else requestAnimationFrame(update);
            }

            chainTimeouts(
            function(){hideCursor("canvasContainer");},500,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},1500,
            function ()
            {
                motionTimer = 0;
                motionIterations = Math.floor(duration/1000*60);

                requestAnimationFrame(update);
            });
        }

        function nextTrial()
        {
            for(var i = 0; i < numTargets; i++) targets[i] = 0;

            // read the frame sequence one frame at a time
            if(frame = frameSequence.shift())
            {
                // check if it's the startup frame
                if (frame.type === "begin")
                    showAlert(frame.message,
                    "Click here for instructions",
                    function ()
                    {
                        nextTrial();
                    });
                // else if it's a message frame, show it
                else if (frame.type === "message")
                    showAlert(frame.message,
                    "Click here to continue",
                    function ()
                    {
                        showFrame("null");
                        nextTrial();
                    });
                // else show the animation
                else
                {
                    numCircles=frame.n_circles;
                    numTargets=frame.n_targets;
                    mycircle.speed=frame.speed;
                    duration=frame.duration;

                    showMovingDots();
                }
            }
            // else the sequence is empty, we are done!
            else
            {
                outcomes.score = score;
                outcomes.correct = (score / total).round(3);
                outcomes.rtTotal = results.filter(function( obj )
                                                 {return obj.type !== 'practice' &&
                                                         obj.state !== 'timeout';})
                                          .pluck("rt").sum().round(1);
                outcomes.frametime = frametime;

                if(debug === "true")
                console.log("Score is " + score + " out of " + total);

                // we either save locally or to the server
                if(showresults === "true" || autosave === 'true' || filename)
                {
                    showAlert("<br><br>Your score is " + score + ".<br>" +
                              "<br>The test is over.<br>" +
                              "Thank you for participating!<br><br>",
                              "",
                              null);

                    setTimeout(function()
                    {
                        if(filename === false) filename = "MOTresults.csv";
                        tmbSubmitToFile(results,filename,autosave);
                    },2000);
                }
                else
                {
                    tmbSubmitToServer(results,score,outcomes,'/run.php');
                }
            }
        }

        function setFrameSequence()
        {
            var testMessage =
            {
                "begin":("<h2>Multiple Object Tracking</h2>" +
                         "<img src=MOT.gif><br><br>"),
                "instruction1":("<h2>Instructions:</h2>" +
                                "<br><img src=happy-green-border.jpg><br>" +
                                "<br>Keep track of the dots that flash,<br>"+
                                "they have green smiles behind them.<br><br><br>"),
                "practice2":("<h2>Instructions:</h2>" +
                             "Next time, when the movement stops,<br>"+
                             "click the 2 dots that flashed.<br><br>"+
                             "The other dots have<br>"+
                             "red sad faces behind them.<br>"+
                             "<img src=sad-red-border.jpg><br>"+
                             "Try <b><i>not</i></b> to click on those.<br><br>"),
                "practice3":("<br><br><br>Good!<br><br>"+
                             "Now we'll do the same thing with<br>"+
                             "3 flashing dots.<br><br>"),
                "targets3":("<br><br>Great!<br><br>"+
                            "Now we'll do 6 more with 3 dots.<br>"+
                            "Motion is slow at first, then gets faster.<br>"+
                            "This will be the first of 3 parts.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Your score will be the total number of<br>"+
                            "green smiles that you click.<br><br>"),
                "targets4":("<br>Excellent!<br><br>"+
                            "You have finished the first part of this test.<br>"+  "" +
                            "There are two parts left.<br><br>" +
                            "The next part has 4 flashing dots.<br>"+
                            "Motion is slow at first, then gets faster.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Every smile you click adds to your score!<br><br>"),
                "targets5":("<br>Outstanding!<br><br>"+
                            "Now there is only one part left!<br><br>" +
                            "The final part has 5 flashing dots!<br>"+
                            "Motion is slow at first, then gets faster.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Every smile you click adds to your score!<br><br>")
            };

            // set the random generator's seed
            var s = seed;

            var frame_type = ["begin","message",
                              "example","message",
                              "practice","message","practice"];
            var frame_message = [testMessage.begin,testMessage.instruction1,
                                 "example1",testMessage.practice2,
                                 "practice1",testMessage.practice3,"practice2"];
            var frame_ntargets = [0,0,2,0,2,0,3];
            var frame_speed = [0,0,0.5,0,0.5,0,0.5];

            // instructions and practice phase
            for(var i = 0; i < frame_type.length; i++)
            {
                frameSequence.push(
                        {
                            type: frame_type[i],
                            n_targets: frame_ntargets[i],
                            n_circles: numCircles,
                            speed: frame_speed[i],
                            duration: 3000,
                            message: frame_message[i]
                        });
            }

            // test 3 dots
            frame_type = ["message","test","test","test","test","test","test"];
            frame_message = [testMessage.targets3,"test"+(s),"test"+(s+1),"test"+(s+2),
                             "test"+(s+3),"test"+(s+4),"test"+(s+5),"test"+(s+6)];
            frame_speed = [0,1,2,3,4,5,6];

            for(i=0; i<frame_type.length; i++)
            {
                frameSequence.push(
                        {
                            type: frame_type[i],
                            n_targets: 3,
                            n_circles: numCircles,
                            speed: frame_speed[i],
                            duration: duration,
                            message: frame_message[i]
                        });
                if(demo==="true" && i===1) break;
            }

            // test 4 dots
            frame_message = [testMessage.targets4,"test"+(s+10),"test"+(s+11),"test"+(s+12),
                             "test"+(s+13),"test"+(s+14),"test"+(s+15),"test"+(s+16)];

            for(i=0; i<frame_type.length; i++)
            {
                frameSequence.push(
                        {
                            type: frame_type[i],
                            n_targets: 4,
                            n_circles: numCircles,
                            speed: frame_speed[i],
                            duration: duration,
                            message: frame_message[i]
                        });
                if(demo==="true" && i===1) break;
            }

            // test 5 dots
            frame_message = [testMessage.targets5,"test"+(s+20),"test"+(s+21),"test"+(s+22),
                             "test"+(s+23),"test"+(s+24),"test"+(s+25),"test"+(s+26)];

            for(i=0; i<frame_type.length; i++)
            {
                frameSequence.push(
                        {
                            type: frame_type[i],
                            n_targets: 5,
                            n_circles: numCircles,
                            speed: frame_speed[i],
                            duration: duration,
                            message: frame_message[i]
                        });
                if(demo==="true" && i===1) break;
            }

            nextTrial();
        }

        window.onload = function()
        {
            // see if they are just asking for help
            if ((usage = getUrlParameters("help", "", true)))
            {
                showAlert("<b>Usage:</b><br>MOT.html?urlparam1=true&urlparam2=false<br><br>" +
                    "<b>URL Parameters</b>:<br>" +
                    "debug=true -- outputs trial by trial info to the console<br>" +
                    "showresults=true -- allows to save results locally in a file<br>" +
                    "autosave=true -- attempt to save results automatically to file<br>" +
                    "filename=subject1.csv -- the filename to save results to<br>" +
                    "demo=true -- do a quick run through<br>" +
                    "seed=1234 -- a numeric random generator seed<br>" +
                    "dots=10 -- total dots to display (6-20)<br>" +
                    "help -- print this message");
                return;
            }

            // check if this is a debug session
            debug = getUrlParameters("debug", "", true);

            // check if they want to load results in a new page when the test is over,
            // if data is to be saved automatically to a file and the filename
            showresults = getUrlParameters("showresults", "", true);
            autosave = getUrlParameters("autosave", "", true);
            filename = getUrlParameters("filename", "", true);

            // check if they want a quick run-through (only 1 trial per block)
            demo = getUrlParameters("demo","",true);

            // check if they want to change # of dots
            dots = getUrlParameters("dots","",true);
            if((dots = parseInt(dots)) > 5 && dots <= 20) numCircles = dots;

            // check if they want to set a random seed
            seed = getUrlParameters("seed","",true);
            if(!(seed = parseInt(seed))) seed = 1;

            // setup a canvas for Snap objects
            paper = Snap(paperSize, paperSize);
            getID("canvasContainer").appendChild(paper.node);

            // disable spurious user interaction
            disableSelect();
            disableRightClick();
            disableDrag();

            setMobileViewportScale(560,600);

            getFrameTime(10,function(interval){frametime = interval;});

            var images = ['MOT.gif','happy-green-border.jpg','sad-red-border.jpg'];

            imagePreLoad(images,{callBack: setFrameSequence});
        }

    </script>

<!-- end of js script ****************************************************** -->

</head>

<!-- HTML content ********************************************************** -->

<body>

    <!-- this DIV is used to show a message and continue the test sequence -->
    <div id="alertBox" class="inst" style="display: none">
        <span class="instSpan" id="alertText">This is a placeholder.</span>
        <button type="button" class="button" id="alertButton">Click here</button>
    </div>

    <!-- this DIV contains the stimulus canvas -->
    <div class="stim" id="canvasContainer" style="display: none">

    </div>

    <!-- this DIV is used to give feedback -->
    <div class="feedback" id="feedback" style="display: none">
        <span id="textLeft"></span>
        <span id="textMiddle"></span>
        <span id="textRight"></span>
    </div>

    <noscript>
        For full functionality of this site it is necessary to enable JavaScript.<br>
        Here are the <a href="http://www.enable-javascript.com/" target="_blank">
        instructions</a> how to enable JavaScript in your web browser.
    </noscript>

</body>

</html>